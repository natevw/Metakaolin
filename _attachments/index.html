<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Metakaolin</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <script src="d3.min.js"></script>
    <script src="fermata.min.js"></script>
    <script src="memcouch.js"></script>
    <script src="memcouch.pouchdb.js"></script>
    <script src="pouch.alpha.min.js"></script>
    <script src="polymaps.min.js"></script>
    <script src="polymaps.editor.js"></script>
    <script src="polymaps.viewer.js"></script>
    
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
        }
        html {
            font-family: "Trebuchet MS", sans-serif;
        }
        .menuBar {
            position: absolute;
            left: 0; right: 0;
            z-index: 1;
            height: 44px;
            display: -webkit-box; display: -moz-box;
            -webkit-box-orient: horizontal; -moz-box-orient: horizontal;
            box-shadow: 0 1px 2px black;
            background: black;
        }
        .menuBar > * {
            display: block;
            line-height: 44px;
            min-width: 44px;
            color: white;
            background: grey;
            text-align: center;
            margin: 0 1px;
            padding: 0 5px;
        }
        .menuBar > :first-child { margin-left: 0; }
        .menuBar > :last-child { margin-right: 0; }
        .menuBar > .title {
            font-size: 100%;
            font-weight: normal;
            -webkit-box-flex: 1; -moz-box-flex: 1;
        }
        a, a:visited {
            color: darkblue;
        }
        a:hover {
            color: blue;
        }
        a.action {
            -webkit-user-select: none;
            cursor: pointer;
        }
        .mainContent {
            display: block;
            position: absolute;
            top: 44px; bottom: 0px;
            left: 0; right: 0;
        }
        
        .mainContent.listView {
            overflow: auto;
        }
        .mainContent.listView ul.maps {
            padding-left: 0;
        }
        .mainContent.listView ul.maps > li {
            list-style: none;
            margin: 1em; padding: 1em;
            border: 1px solid grey;
            border-radius: 5px;
            background: #eee;
            color: black;
        }
        .mainContent.listView ul.maps > li.addMap {
            text-align: center;
            color: grey;
        }
        .mainContent.listView ul.maps > li > h2 {
            margin: 0;
            font-weight: normal;
        }
        .mainContent.listView ul.maps > li > span {
            margin: 0;
            font-size: 75%;
            font-style: italic;
        }
        .mainContent.listView ul.maps > li > .delete, .dialogContent .delete {
            color: darkred;
            float: right;
        }
        .dialogContent .delete {
            padding-top: 22px;
        }
        
        .mainContent.mapView {
            overflow: hidden;       /* not sure why necessary, but otherwise simply adding svg element causes 4px body overflow */
        }
        .mainContent.mapView > .map {
            width: 100%; height: 100%;
        }
        .mainContent.mapView  .mapCredit {
            position: absolute;
            margin: 0;
            right: 4px; bottom: 4px;
            font-size: 50%;
            background: rgba(150,150,150,0.5);
            border-radius: 2px;
            padding: 2px 5px;
        }
        .mainContent.mapView > .add {
            display: block;
            position: absolute;
            top: 25px; left: 5px;
            text-align: center;
            line-height: 1em; font-family: "Courier New", "Courier", monospace; font-weight: bold;
            width: 1em; height: 1em;
            border-radius: 1em;
            border: 2px solid white;
            background: black;
            color: white;
            font-size: 44px;
        }
        
        .viewer { fill: grey; fill-opacity: 0.5; stroke: black; }
        .viewer polyline { fill: none !important; stroke-width: 3px; }
        .viewer .hover { fill-opacity: 0.25; stroke-opacity: 0.75; }
        .viewer .color0 { fill: #311; stroke: #311; }
        .viewer .color1 { fill: #131; stroke: #131; }
        .viewer .color2 { fill: #113; stroke: #113; }
        .mainContent.mapView.editing .viewer { opacity: 0.1; }
        .mainContent.mapView.editing .viewer .hover { fill-opacity: inherit; stroke-opacity: inherit; }
        
        .dialog {
            position: absolute;
            top: 0; bottom: 0;
            left: 0; right: 0;
            z-index: 2;
            background: rgba(127,127,127,0.75);
        }
        .dialog > .frame {
            position: absolute;
            top: 22px; bottom: 22px;
            left: 75px; right: 75px;
            background: #fefeff;
            box-shadow: 2px 2px 16px 2px black;
            border-radius: 3px;
            overflow: hidden;
        }
        .dialog > .frame > h2 {
            text-align: center;
        }
        .dialog .dialogContent {
            top: 4em; bottom: 4em;
            left: 0; right: 0;
            overflow: auto;
            padding: 0 1em;
        }
        .dialog > .frame > .done {
            display: block;
            position: absolute;
            bottom: 0; width: 100%;
            text-align: center;
            border-top: 1px solid black;
            padding: .5em;
            font-size: 1.5em; color: white;
            background: #333;
        }
        
        .dialogContent > label {
            display: block;
            font-size: 1.25em;
            margin-bottom: 22px;
        }
        .dialogContent input, .dialogContent select {
            display: block;
            width: 100%;
            font-size: 35px;
        }
        .dialog .docSettings .mapCredit {
            font-size: 50%;
            font-variant: italic;
            margin-top: 0;
            padding: 0 8px;
        }
        
        .dialog .colorChoices > li {
            cursor: pointer;
            display: inline-block;
            width: 44px; height: 44px;
            vertical-align: top;
            background: #eee;
            font-size: 50%;
            text-align: center;
            box-sizing: border-box;
            padding-top: 16px;
            border: 1px solid grey;
            margin: 1px;
        }
        .dialog .colorChoices > li.selected {
            border: 4px dotted #66f;
        }
        
    </style>
</head>
<body>
<script>
function stage(container) {
    var stage = {};
    
    var root = d3.select(container).html('').classed('stage', true),
            menuBar = root.append('header').classed('menuBar', true),
                backButton = menuBar.append('a').classed('action', true).classed('back', true).text("← Back"),
                mainTitle = menuBar.append('h1').classed('title', true).classed('bar', true).text("Untitled scene"),
                menuButton = menuBar.append('a').classed('action', true).classed('menu', true).text("Edit…"),
            content = root.append('div').classed('mainContent', true),
            dialog = root.append('div').classed('dialog', true).style('display', "none"),
                dialogFrame = dialog.append('div').classed('frame', true),
                    dialogTitle = dialogFrame.append('h2').text("Extra options"),
                    dialogContent = dialogFrame.append('div').classed('dialogContent', true),
                    dialogDone = dialogFrame.append('a').classed('action', true).classed('done', true).text("Done");
    
    // WORKAROUND: Firefox won't display [old-style] flexbox if positioned absolute http://stackoverflow.com/a/9163605/179583
    if (~navigator.userAgent.indexOf('Firefox')) menuBar.style('position', "static").style('width', "100%");
    
    /*
    mainStage.push(function () {
        this.scene("Shapes", function (container) {
            // set up main view
            return function () {
                // tear down main view
            };
        })
        this.title(doc.title, "Zoom to extent", function () {
        
        })
        this.extra("Options", "View layer options", function () {
            
        });
    });
    */
    
    var scenes = [],
        exitPreviousView;
    function activate(scene, prev) {
        var backTitle = "Back", backTooltip = "Return to previous";
        var modifiers = {
            back: function (title, tip, action) {
                if (title) backButton.style('display', null).text("← " + title).attr('title', tip).on('click', action);
                else backButton.style('display', "none");
            },
            scene: function (nickname, view, data) {
                backTitle = nickname;
                if (exitPreviousView) exitPreviousView();
                exitPreviousView = view(content.node(), data);
            },
            title: function (title, tip, action) {
                backTooltip = "Return to " + title;
                mainTitle.text(title).attr('title', tip || null).on('click', action || null);
            },
            extra: function (title, tip, dialog) {
                if (title) menuButton.style('display', null).text(title + "…").attr('title', tip).on('click', function () {
                    stage.dialog(tip, dialog);
                });
                else menuButton.style('display', "none");
            }
        };
        modifiers.back(prev.title, prev.tooltip, stage.pop);
        modifiers.scene("Back", function () {});
        modifiers.title("Return to previous");
        modifiers.extra(null);
        scene.call(modifiers);
        stage.dialog(null);
        return {title:backTitle, tooltip:backTooltip};
    }
    stage.push = function (scene) {
        var prev = scenes[scenes.length - 1],
            sceneInfo = activate(scene, prev || {});
        sceneInfo.scene = scene;
        scenes.push(sceneInfo);
    };
    stage.pop = function () {
        scenes.pop();
        var scene = scenes[scenes.length - 1].scene,
            prev = scenes[scenes.length - 2],
            sceneInfo = activate(scene, prev || {});
        sceneInfo.scene = scene;
        scenes[scenes.length - 1] = sceneInfo;
    };
    
    var cleanupDialog;
    stage.dialog = function (title, view, data) {
        if (title) {
            dialog.style('display', null);
            dialogTitle.text(title);
            cleanupDialog = view(dialogContent.node(), data);
            dialogDone.on('click', function () { stage.dialog(null); });
        } else {
            if (cleanupDialog) cleanupDialog();
            dialog.style('display', "none");
        }
    };
    return stage;
};


var model = memcouch.db();

var mainStage = stage(document.body);
mainStage.push(function () {
    this.scene("Maps", listView);
    this.title("All maps");
    //this.extra("Setup", "Adjust application settings", function () {});
});

var MAP_OPTIONS = [{
    key:'argyles',
    url: org.polymaps.url("http://temp{S}.argyl.es/preview-key/{Z}/{X}/{Y}.jpg").hosts([1, 2, 3]),
    name:"Argyle Tiles (offline demo)",
    attr: "Argyle Tiles hosted by <a href=\"http://exts.ch\">Nathan Vander Wilt</a>, data courtesy NASA-JPL and USGS."
},{
    key:'mbs', name:"MapBox Satellite",
    url: org.polymaps.url("http://{S}tiles.mapbox.com/v3/natevw.map-u490f7en/{Z}/{X}/{Y}.jpg").hosts(["a.", "b.", "c.", "d."]),
    attr: "<a href=\"http://mapbox.com/blog/mapbox-satellite/\">MapBox Satellite</a> tileset, data courtesy U.S. government agencies."
},{
    key:'moa', name:"Mapquest Open Aerial",
    url: org.polymaps.url("http://otile{S}.mqcdn.com/tiles/1.0.0/sat/{Z}/{X}/{Y}.jpg").hosts([1,2,3,4]),
    attr: "Portions Courtesy NASA/JPL-Caltech and U.S. Depart. of Agriculture, Farm Service Agency. Tiles Courtesy of <a href=\"http://www.mapquest.com/\">MapQuest</a>."  
},{
    key:'osm', name:"OpenStreetMap",
    url: org.polymaps.url("http://{S}tile.openstreetmap.org/{Z}/{X}/{Y}.png").hosts(["a.", "b.", "c.", ""]),
    attr: "© OpenStreetMap contributors. <a href=\"http://www.openstreetmap.org/copyright\">Learn more.</a>"
},{
    key:'cm', name:"Stamen Toner",
    url: org.polymaps.url("http://tile.stamen.com/toner-lite/{Z}/{X}/{Y}.png").hosts(["a.", "b.", "c.", "d.", ""]),
    attr:"Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, under <a href=\"http://creativecommons.org/licenses/by-sa/3.0\">CC BY SA</a>."
}];

var SHAPE_COLORS = [
    {name:"Black", val:"black"},
    {name:"Grey", val:"grey"},
    {name:"White", val:"white"},
    {name:"Red", val:"red"},
    {name:"Orange", val:"orange"},
    {name:"Yellow", val:"yellow"},
    {name:"Green", val:"green"},
    {name:"Blue", val:"blue"},
    {name:"Indigo", val:"indigo"},
    {name:"Violet", val:"violet"}
];


function listView(container) {
    var root = d3.select(container).html('').classed('listView', true),
            list = root.append('ul').classed('maps', true),
                addMap = list.append('li').classed('addMap', true).append('h2').append('a').classed('action', true).text("New map…");
    
    function openDocument(doc) {
        mainStage.push(function () {
            var ctx = {doc:doc},
                mapInfoByKey = {};
            MAP_OPTIONS.forEach(function (info) { mapInfoByKey[info.key] = info; });
            this.scene("Features", mapView, ctx);
            this.title(doc.title || "Untitled", "Zoom to fit", ctx.zoomToDoc);
            this.extra("Edit", "Map document settings", function (container) {
                var root = d3.select(container).html('').classed('docSettings', true),
                    nameLabel = root.append('label').text("Map name:"),
                        nameInput = nameLabel.append('input').attr('value', doc.title),
                    basemapLabel = root.append('label').text("Basemap style:"),
                       basemapOptions = basemapLabel.append('select'),
                       basemapCredit = basemapLabel.append('p').classed('mapCredit', true),
                    deleteDoc = root.append('a').classed('action', true).classed('delete', true).text("Delete?");
                
                basemapOptions.selectAll('option').data(MAP_OPTIONS).enter().append('option').attr('value', function (d) { return d.key; }).text(function (d) { return d.name; });
                basemapOptions.on('change', function () {
                    doc.basemap = basemapOptions.property('value');
                    basemapCredit.html(mapInfoByKey[doc.basemap].attr);
                    showBasemap();
                }).property('value', doc.basemap);
                basemapCredit.html(mapInfoByKey[doc.basemap].attr);
                
                deleteDoc.on('click', function () {
                    var really = confirm("This document will be almost permanently deleted.");
                    if (!really) return;
                    model.del(doc._id);
                    mainStage.pop();
                });
                
                return function () {
                    doc.title = nameInput.property('value');
                    model.put(doc);
                    root.classed('docSettings', false);
                };
            });
            
            doc.basemap || (doc.basemap = MAP_OPTIONS[0].key);
            function showBasemap() {
                var basemap = mapInfoByKey[doc.basemap];
                ctx.basemap.url(basemap.url);
                ctx.mapCredit.html(basemap.attr);
            }
            showBasemap();
        });
    }
    
    addMap.attr('href', "#").on('click', function () {
        d3.event.preventDefault();
        var doc = {
            'com.stemstorage.geodoc':true,
            _id: 'geodoc-' + memcouch.id(),
            content: {type:"FeatureCollection", features:[]},
            created: new Date().toISOString(),
            title: "Untitled map"
        };
        doc.last_modified = new Date().toISOString();
        model.put(doc);
        openDocument(doc);
    });
    
    function updateList() {
        var data = model.query(function (doc) {
            if (doc['com.stemstorage.geodoc']) this.emit(doc.last_modified);
        }, true).map(function (row) { return row.doc; }).reverse();
        
        var mapItems = list.selectAll('li:not(.addMap)').data(data, function (d) { return d._id; }),
            mapItemsEnter = mapItems.enter().insert('li', ".addMap");
        mapItemsEnter.append('h2').append('a');
        mapItemsEnter.append('span');
        //mapItemsEnter.append('a').classed('action', true).classed('delete', true).text("Delete?");
        mapItems.select('h2 > a').text(function (d) { return d.title || "- untitled -"; }).attr('href', function (d) { return "#" + d._id; }).on('click', function (d) {
            d3.event.preventDefault();
            openDocument(d);
        });
        mapItems.select('span').text(function (d) { return d.last_modified; });
        mapItemsEnter.select('.delete').on('click', function (d) {
            var really = confirm("This document will be almost permanently deleted.");
            if (!really) return;
            model.del(d._id);
        });
        mapItems.exit().remove();
        mapItems.order();
    }
    model.watch(updateList);
    updateList();
    
    return function () {
        root.classed('listView', false);
        model.clear(updateList);
    };
}

function mapView(container, ctx) {
    var root = d3.select(container).html('').classed('mapView', true),
            map = root.append('svg:svg'),
            addButton = root.append('a').classed('action', true).classed('add', true).text("+"),
            mapCredit = root.append('p').classed('mapCredit', true);
    
    var po = org.polymaps,
        map = po.map().container(map.node()),
        DEFAULT_BOUNDS = [{"lon":-119.55479507338985,"lat":46.04672743284027},{"lon":-118.709894726065,"lat":46.3892651319496}];
    map.add(po.interact()).zoomRange([0,24]);
        // TODO: properly attribute whichever layer is used
    var tiles = po.image().on('load', function (e) {
        // https://github.com/simplegeo/polymaps/issues/36
        e.tile.element.width.baseVal.value += 1;
        e.tile.element.height.baseVal.value += 1;
    }).zoom(function(z) { return Math.max(0, Math.min(18, z)); });
    map.add(tiles);
    
    // expose these for dialog use
    ctx.basemap = tiles;
    ctx.mapCredit = mapCredit;
    
    var doc = ctx.doc,
        vector = po_metakaolin_viewer(),
        editor = po_metakaolin_editor();
    vector.on('show', function (loadEvent) {
        if (loadEvent.features) loadEvent.features.forEach(function (f,i) {
            d3.select(f.element).on('click', function () {
                d3.event.stopPropagation();
                d3.event.preventDefault();
                addButton.style('display', "none");
                editFeature(f.data);
            }).on("mouseover", function () {
                d3.select(this).classed('hover', true);
            }).on("mouseout", function () {
                d3.select(this).classed('hover', false);
            }).classed('color' + (i % 3), true).style('stroke', f.data.color).style('fill', f.data.color);
            console.log(f.data);
        });
    }).features(doc.content.features);
    d3.select(vector.container()).classed('viewer', true);
    map.add(vector).add(editor);
    
    addButton.on('click', function () {
        d3.event.preventDefault();
        addFeature();
    });
    
    function zoomableBounds(feature) {
        var bounds = d3.geo.bounds(feature).map(function (c) { return {lon:c[0], lat:c[1]}; }),
            MIN_DIFF = 0.0005,
            SINGLE_D = 0.01;            // zoom a lot wider for single points
        if (bounds[0].lat === bounds[1].lat && bounds[0].lon === bounds[1].lon) {
            bounds[0].lat -= SINGLE_D / 2;
            bounds[1].lat += SINGLE_D / 2;
            bounds[0].lon -= SINGLE_D / 2;
            bounds[1].lon += SINGLE_D / 2;
            return bounds;
        }
        // pad features that are just legitimately tiny
        if ((bounds[1].lat - bounds[0].lat) < MIN_DIFF) {
            bounds[0].lat -= MIN_DIFF / 2;
            bounds[1].lat += MIN_DIFF / 2;
        }
        if ((bounds[1].lon - bounds[0].lon) < MIN_DIFF) {
            bounds[0].lon -= MIN_DIFF / 2;
            bounds[1].lon += MIN_DIFF / 2;
        }
        return bounds;
    }
    
    function zoomToDoc() {
        if (!doc.content.features.length) {
            map.extent(DEFAULT_BOUNDS);
            return;
        }
        var bounds = zoomableBounds(doc.content);
        map.extent(bounds).zoomBy(-0.25);
    }
    zoomToDoc();
    
    ctx.zoomToDoc = zoomToDoc;
    
    function addFeature() {
        var feat = {type:"Feature", properties:null},
            geom = {type:"Point", coordinates:[]},
            center = map.center();
        geom.coordinates.push(center.lon);
        geom.coordinates.push(center.lat);
        feat.geometry = geom;
        feat._new = true;
        doc.content.features.push(feat);
        editFeature(feat);
    }
    
    function editFeature(feature) {
        function zoomToFeature() {
            if ('_new' in feature) {
                // for brand new features, we skip initial zoom since user likely already found desired context
                delete feature._new;
                return;
            }
            var zoomFeature = editor.geometry(),
                bounds = zoomableBounds(zoomFeature);
            map.extent(bounds).zoomBy(-0.25);
        }
        mainStage.push(function () {
            var featureName = (feature.properties && typeof feature.properties === 'object') ? feature.properties.name : feature.properties,
                ctx = {map:map, layer:editor, geometry:feature.geometry};
            ctx.removeShape = function () {
                var features = doc.contents.features,
                    featureIdx = features.indexOf(feature);
                if (~featureIdx) features.splice(featureIdx, 1);
            };
            this.scene("Edit", shapeView, ctx);
            this.title("Editing " + ((featureName) ? ('"' + featureName + '"') : "shape"), "Zoom map to fit shape", zoomToFeature);
            this.extra("Details", "Feature details", function (container) {
                var nameProp = feature.properties;
                var root = d3.select(container).html('').classed('shapeDetails', true),
                        nameLabel = root.append('label').text("Name").attr('title', "Enter a name (or JSON properties) for this feature"),
                           nameEntry = nameLabel.append('input').attr('value', (nameProp && typeof nameProp === 'object') ? JSON.stringify(nameProp) : nameProp),
                        colorLabel = root.append('h3').text("Choose a color:"),
                        colorOptions = root.append('ul').classed('colorChoices', true),
                        deleteShape = root.append('a').classed('action', true).classed('delete', true).text("Remove feature?");
                
                colorOptions.selectAll('li').data(SHAPE_COLORS).enter()
                    .append('li').style('background', function (d) { return d.val; }).attr('title', function (d) { return d.name; }).on('click', function (d) {
                        feature.color = d.val;
                        updateColorSelection();
                    });
                colorOptions.insert('li', "li").text("None").attr('title', "Don't assign a color").on('click', function () {
                    delete feature.color;
                    updateColorSelection();
                });
                function updateColorSelection() {
                    colorOptions.selectAll('li').classed('selected', function (d) {
                        return (d) ? d.val === feature.color : !feature.color;
                    });
                }
                updateColorSelection();
                
                deleteShape.on('click', function () {
                    var really = confirm("This feature will be removed from the map.");
                    if (!really) return;
                    ctx.removeShape();
                    mainStage.pop();
                });
                
                return function () {
                    try {
                        // if text field looks like JSON, use its value
                        feature.properties = JSON.parse(nameEntry.property('value'))
                    } catch (e) {
                        // otherwise just assign as string/null
                        feature.properties = nameEntry.property('value') || null;
                    }
                    root.classed('shapeDetails', false);
                };
            });
            zoomToFeature();
        });
    }
    
    return function () {
        doc.last_modified = new Date().toISOString();
        model.put(doc);
        root.classed('mapView', false);
    };
}


function shapeView(container, ctx) {
    var root = d3.select(container)/*.html('')*/.classed('mapView', true).classed('editing', true);      // assume container is shared and just use existing map
    
    ctx.layer.geometry(ctx.geometry);
    
    return function () {
        var editor = ctx.layer,
            newGeometry = editor.geometry(),
            editingGeometry = ctx.geometry;
        Object.keys(newGeometry).forEach(function (key) {
            editingGeometry[key] = newGeometry[key];
            if (key === "geometries") delete editingGeometry["coordinates"];
            if (key === "coordinates") delete editingGeometry["geometries"];
        });
        editor.geometry(null);
        root.classed('editing', false).classed('mapView', false);
    }
}

Pouch("idb://metakaolin", function (e,db) {
    if (e) throw e;
    dbgDB = db;
    
    var status = memcouch.slaveToPouch(model, db);
    window.addEventListener('beforeunload', function () {
        if (status.changesPending) return (e.returnValue = "Not all of your changes have been saved to disk yet, please wait!");
    }, false);
    
    // TODO: move this to visible, app-level configuration when integrating back into CouchDB
    if (0 && location.protocol !== 'file:') {
        var ddocIdx = location.href.indexOf("/_design/"),
            ddocName = location.href.slice(ddocIdx).split('/')[2],
            dbURL = (~ddocIdx) ? location.href.slice(0, ddocIdx) : "";     // if no ddoc in URL, just try root I guess?
        Pouch.replicate(dbURL, db, {continuous:false, filter:ddocName+"/geodocs"});
        Pouch.replicate(db, dbURL, {continuous:true});
    }
});

</script>
</body>
</html>